# Movie-app
Code repository for NIIT Capstone project - Movie App

Controller: @GetMapping(value = "/generateExcelZohoTxn", produces = { MediaType.APPLICATION_JSON_VALUE }) @ResponseBody @ApiOperation(value = "Zoho Transaction Download") public ResponseEntity<Object> generateExcelZohoTxn(HttpServletRequest request, HttpServletResponse response) { logger.logMethodStart(MessageConstants.METHOD_GENERATE_EXCEL_ZOHO_TXN); try{ logger.info("Inside controller"); return zohoToNiveusService.generateExcelForZohoTxn(request, response); // HttpHeaders headersResponse = new HttpHeaders(); // headersResponse.add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=zoho_transactions.xlsx"); // headersResponse.add(HttpHeaders.CONTENT_TYPE, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); // headersResponse.setContentLength(excelData.length); // Set content length header // return new ResponseEntity<>(excelData, headersResponse, HttpStatus.OK); }catch (CustomException e) { logger.logException(MessageConstants.METHOD_GENERATE_EXCEL_ZOHO_TXN, e); return CommonUtils.generateErrorResponse(HttpStatus.BAD_REQUEST.value(), e.getMessage(), null); } catch (Exception e) { logger.logException(MessageConstants.METHOD_GENERATE_EXCEL_MIS_REPORT, e); return CommonUtils.generateErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), MessageConstants.INTERNAL_SERVER_ERROR, null); } } Service: public ResponseEntity<Object> generateExcelForZohoTxn(HttpServletRequest request, HttpServletResponse response) { logger.info("Starting to generate Excel file for ZohoTxn."); byte[] excelData = null; try { // Fetch data from the repository List<newLhsDto> transactions = jdbcTemplateRepository.getAllZohoTransactions(); logger.info("Fetched Zoho transactions."); // transactions.addAll(jdbcTemplateRepository.getAllOfflineTransactions()); // Define headers // String[] headers = {"id", "Offline Transaction Id", "Online Transaction Id", "Transaction Number", "Client Name", "Amount", "Cheque Number", "Date", "Account no", "Pan"}; // Generate Excel data if (!transactions.isEmpty()) { export.downloadReport(transactions, request, response, MessageConstants.ZOHO_TXN_FILE_NAME, ReportFormatEnum.XLSX); }else { export.download(new byte[0], request, response, MessageConstants.ZOHO_TXN_FILE_NAME + MessageConstants.XLSX_EXTENSION, MessageConstants.XLSX_CONTENT_TYPE); } // excelData = ExcelUtil.generateExcelAsByteArray(headers, transactions); } catch (Exception e) { logger.error("Error occurred while generating Excel file for ZohoTxn: ", e); } return null; } public <T> void downloadReport(List<T> data, HttpServletRequest request, HttpServletResponse response, String fileName, ReportFormatEnum format) throws IOException { switch (format) { case XLSX: this.download(this.generateExcel(data), request, response, fileName + ".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); default: } } public void download(byte[] file, HttpServletRequest request, HttpServletResponse response, String fileName, String contentType) throws IOException { String headerKey = "Content-Disposition"; String headerValue = String.format("attachment; filename=\"%s\"", fileName); response.setHeader(headerKey, headerValue); response.setContentType(contentType); response.addHeader("Access-Control-Expose-Headers", "content-disposition"); OutputStream out = response.getOutputStream(); out.write(file); out.flush(); out.close(); } public <T> byte[] generateExcel(List<T> data) { XSSFWorkbook workbook = null; ByteArrayOutputStream fos = new ByteArrayOutputStream(); byte[] byteArray = null; try { workbook = new XSSFWorkbook(); Sheet sheet = workbook.createSheet(); List<String> fieldNames = this.getFieldNamesForClass(data.get(0).getClass()); int rowCount = 0; int columnCount = 0; Row row = sheet.createRow(rowCount++); Iterator var10 = fieldNames.iterator(); while(var10.hasNext()) { String fieldName = (String)var10.next(); Cell cell = row.createCell(columnCount++); cell.setCellValue(StringUtils.capitalize(fieldName.replaceAll("([^_])([A-Z])", "$1 $2"))); } Class<? extends Object> classz = data.get(0).getClass(); Iterator var31 = data.iterator(); while(var31.hasNext()) { T t = var31.next(); row = sheet.createRow(rowCount++); columnCount = 0; for(Iterator var13 = fieldNames.iterator(); var13.hasNext(); ++columnCount) { String fieldName = (String)var13.next(); Cell cell = row.createCell(columnCount); Method method = null; try { method = classz.getMethod("get" + this.capitalize(fieldName)); } catch (NoSuchMethodException var27) { method = classz.getMethod("get" + fieldName); } Object value = method.invoke(t, (Object[])null); if (value != null) { if (value instanceof String) { cell.setCellValue((String)value); } else if (value instanceof Long) { cell.setCellValue((double)(Long)value); } else if (value instanceof Integer) { cell.setCellValue((double)(Integer)value); } else if (value instanceof Double) { cell.setCellValue((Double)value); } else if (value instanceof Boolean) { cell.setCellValue(value.toString()); } } } } for(int i = 0; i < fieldNames.size(); ++i) { sheet.autoSizeColumn(i); } workbook.write(fos); fos.flush(); byteArray = fos.toByteArray(); } catch (Exception var28) { logger.logException("generateExcel", var28, new Object[]{"generateExcel"}); } finally { try { if (fos != null) { fos.close(); } } catch (IOException var26) { logger.logException("generateExcel", var26, new Object[]{"generateExcel"}); } } return byteArray; } Now these are the complete api where in frontend they are expecting the blob format but it is in binary data so could you help me fix this issue
